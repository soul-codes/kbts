import { customName, firstKB, linkExample } from "./examples";

import {
  api,
  block,
  codeBlock,
  codeBlockLang,
  d,
  em,
  inline,
  kb,
  code,
  link,
  list,
  quote,
  remark,
  s,
} from "kbts";
import { preferredFilename, render, save } from "kbts/markdown";
import rimraf from "rimraf";
import { install } from "source-map-support";
import { pkg, pkgRef, pkgVersion, tsPluginRef } from "./pkgRef";

install();
const pwd = process.cwd();

rimraf.sync("./docs");

const readme = kb(`${pkg} - a documentation-as-code library for TypeScript`)`
  ${remark()("This package is in early development phase!")}

  ${pkgRef} (for "Knowledge Base in TypeScript") presents a
  documentation-as-code solution where units of documentation
  ("knowledge base" or "KB") are composed programmatically
  to generate documentation. The approach in principle
  allows for different presentations of KBs in various media
  (markdown, CLI, interactive web page, etc); generally, ${pkgRef}
  encourages knowledge to be authored and linked independently of how it
  is presented.

  ${() =>
    list(
      link(apiReference),
      link(kb("Getting Started")`
        ${firstKB}
        ${customName}
        ${linkExample}
`)
    )}

`;

const apiapi = api(
  api,
  (reference) => d`

  ${remark("warning")`
    This feature is experimental, and its behavior and
    interface are unstable!
  `}

  The declaration capturing function. This is a ${em("pragma")}/compiled time
  function which will error out at run time. Instead, you need to use the
  TypeScript plugin that lives in ${tsPluginRef} and an over-TypeScript tool
  such as ${link("https://www.npmjs.com/package/ttypescript", "ttypescript")}
  to process these calls at compile time.

  ${remark("attention")`
    Calling ${code(api.name)} at runtime without having its call processed
    by TypeScript plugin will throw an exception.
  `}

  ${remark("attention")`
    ${code(api.name)} must be called directly or as an ${code("import")} alias.
    The TypeScript plugin will not recognize indirect calls in the sense of
    having ${code(api.name)} assigned to other variables.
  `}

  ${code(api.name)} is designed to capture declaration and type information of
  either the symbol fed as its first argument, or the type declaration of a
  type symbol fed as its first type argument. Further arguments can be supplied
  to customize the rest of the document.

  ${reference}
`
);

const apiList = [
  d`Core API ${list(
    api(kb),
    api(em),
    api(s),
    api(d),
    api(code),
    api(codeBlock),
    api(codeBlockLang),
    api(quote),
    api(remark),
    api(inline),
    api(block),
    apiapi
  )}
  `,
  d`Markdown APIs ${list(api(render), api(preferredFilename))}`,
];

const apiReference = kb("API reference")`
  Version ${pkgVersion}

  ${remark()`
    The API reference itself is generated by ${pkgRef} using the
    ${link(apiapi)} function, which is currently unstable.
  `}

  ${remark()`
    The API reference is work-in-progress, as does not contain complete
    information, although the information here should at least be correct.
  `}

  ${list(...apiList)}
`;

process.chdir(pwd);

save(
  await render([preferredFilename("README.md")(readme)], {
    paths: [
      [readme, "."],
      [null, "./docs"],
    ],
    defaultEmbedCondition: { type: "reference_count", maxReferenceCount: 1 },
  })
);
